# NFT 拍卖市场 - 线上测试操作指南

## 目录

1. [准备工作](#准备工作)
2. [NFT 功能测试](#nft-功能测试)
3. [拍卖功能测试](#拍卖功能测试)
4. [合约升级测试](#合约升级测试)
5. [综合场景测试](#综合场景测试)
6. [测试报告模板](#测试报告模板)

---

## 准备工作

### 1.1 配置环境变量

#### 环境变量文件

项目使用 `.env` 文件管理所有环境变量，Foundry 会自动加载该文件。

**.env 文件结构：**

```bash
# ==============================================================================
# 本地开发配置
# ==============================================================================
PRIVATE_KEY=0x...
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/...
ETHERSCAN_API_KEY=...
ETH_PRICE_FEED=0x694AA1769357215DE4FAC081bf1f309aDC325306
FEE_RECIPIENT=0x...

# ==============================================================================
# Sepolia 线上测试配置
# ==============================================================================
# 测试账户地址
ACCOUNT_A=0x085f0145202298585e699371eb3CFb1441f65110
ACCOUNT_B=0x354C393Daf549Da43485FFe85Be464d82149B0e8
ACCOUNT_C=0x539F128f1Cd5877cA3712ba33f9E78EdFcC7eFAD
ACCOUNT_D=0xd2957b711c6B2291F937471b40ee1272dE171beD

# 已部署合约地址
NFT_CONTRACT_ADDRESS=0x41B2eA52228706FD2a1c81Ab9713A71a710072b4
AUCTION_PROXY_ADDRESS=0x7842104E7ad9f14eCF5aB0352bc6d9d8D6560240
```

#### 使用环境变量

**重要说明**：Foundry 会自动加载 `.env` 文件，但仅对选项参数有效（如 `--rpc-url`）。Shell 变量展开（如 `$ACCOUNT_A`）需要先导出到当前 shell 会话。

**步骤 1：导出环境变量（每个新终端都需要执行一次）**

```bash
# 导出 .env 中的所有变量到当前 shell
export $(grep -v '^#' .env | xargs)

# 验证导出成功
echo $ACCOUNT_A
echo $NFT_CONTRACT_ADDRESS
```

**步骤 2：使用 cast 命令**

```bash
# 查询账户余额
cast balance $ACCOUNT_A --rpc-url $SEPOLIA_RPC_URL

# 或直接使用地址（无需导出变量）
cast balance 0x085f0145202298585e699371eb3CFb1441f65110 --rpc-url $SEPOLIA_RPC_URL
```

### 1.2 安装 Cast 命令行工具

Cast 是 Foundry 提供的命令行工具，用于与以太坊交互：

```bash
# 验证安装
cast --version
```

### 1.3 准备测试账户

建议准备 3-4 个测试账户：

| 账户 | 地址 | 角色 | 用途 |
|-----|------|-----|-----|
| Account A | 0x085f0145202298585e699371eb3CFb1441f65110 | 部署者/Owner | 合约管理、NFT 铸造 |
| Account B | 0x354C393Daf549Da43485FFe85Be464d82149B0e8 | 卖家 | 创建拍卖、出售 NFT |
| Account C | 0x539F128f1Cd5877cA3712ba33f9E78EdFcC7eFAD | 买家 1 | 出价参与拍卖 |
| Account D | 0xd2957b711c6B2291F937471b40ee1272dE171beD | 买家 2 | 竞价参与拍卖 |

### 1.4 获取测试代币

在测试网上，你可能需要：
- **ETH**: 从水龙头获取
- **ERC20 代币**: 可以部署测试 ERC20 代币合约，或使用现有的测试代币

---

## NFT 功能测试

### 2.1 铸造 NFT

使用 Account A（Owner）铸造测试 NFT：

```bash
# 铸造第一个 NFT（tokenId 自动递增）
cast send $NFT_CONTRACT_ADDRESS \
  "mint(address,uint256)" \
  $ACCOUNT_B \
  "https://example.com/nft/1.json" \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY

# 铸造多个 NFT 用于测试
for i in {2..5}; do
  cast send $NFT_CONTRACT_ADDRESS \
    "mint(address,uint256)" \
    $ACCOUNT_B \
    "https://example.com/nft/$i.json" \
    --rpc-url $SEPOLIA_RPC_URL \
    --private-key $PRIVATE_KEY
done
```

### 2.2 查询 NFT 信息

```bash
# 查询 NFT 所有者
cast call $NFT_CONTRACT_ADDRESS \
  "ownerOf(uint256)(address)" \
  1 \
  --rpc-url $SEPOLIA_RPC_URL

# 查询 NFT 元数据 URI
cast call $NFT_CONTRACT_ADDRESS \
  "tokenURI(uint256)(string)" \
  1 \
  --rpc-url $SEPOLIA_RPC_URL

# 查询总供应量
cast call $NFT_CONTRACT_ADDRESS \
  "totalSupply()(uint256)" \
  --rpc-url $SEPOLIA_RPC_URL
```

### 2.3 转移 NFT

```bash
# Account B 将 NFT 转移给 Account C
cast send $NFT_CONTRACT_ADDRESS \
  "safeTransferFrom(address,address,uint256)" \
  $ACCOUNT_B $ACCOUNT_C 1 \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY_B

# 验证转移
cast call $NFT_CONTRACT_ADDRESS \
  "ownerOf(uint256)(address)" \
  1 \
  --rpc-url $SEPOLIA_RPC_URL
# 应返回 Account C 的地址
```

---

## 拍卖功能测试

### 3.1 创建 ETH 拍卖

使用 Account B（卖家）创建 ETH 拍卖：

```bash
# 铸造一个 NFT 给 Account B
cast send $NFT_CONTRACT_ADDRESS \
  "mint(address,uint256)" \
  $ACCOUNT_B \
  "https://example.com/nft/auction-1.json" \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY

# 授权拍卖合约（NFTMarketplace 不需要预授权，因为通过 safeTransferFrom 授权）
# 但如果使用其他 NFT 合约，需要先授权

# 创建拍卖：NFT tokenId=1, 持续时间 1 小时，最低出价 100 USD，接受 ETH
cast send $AUCTION_PROXY_ADDRESS \
  "createAuction(address,uint256,uint256,uint256,address)" \
  $NFT_CONTRACT_ADDRESS \
  1 \
  3600 \
  100000000000000000000 \
  0x0000000000000000000000000000000000000000 \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY_B

# 记录返回的拍卖 ID（auctionId）
```

### 3.2 查询拍卖信息

```bash
# 获取拍卖信息（假设 auctionId = 0）
cast call $AUCTION_PROXY_ADDRESS \
  "getAuction(uint256)(address,address,uint256,uint256,uint256,uint256,uint8,address)" \
  0 \
  --rpc-url $SEPOLIA_RPC_URL

# 返回值解析：
# - seller: 卖家地址
# - nftContract: NFT 合约地址
# - tokenId: NFT ID
# - startTime: 开始时间
# - endTime: 结束时间
# - minBid: 最低出价（USD）
# - status: 状态 (1=Active, 2=Ended, 3=Cancelled)
# - paymentToken: 支付代币（0=ETH）
```

### 3.3 使用 ETH 出价

Account C 出价 0.05 ETH（约 100-200 USD）：

```bash
# 查询当前 ETH 价格
cast call $ETH_PRICE_FEED \
  "latestRoundData()(uint80,int256,uint256,uint256,uint80)" \
  --rpc-url $SEPOLIA_RPC_URL

# 计算：如果 ETH/USD = 2000，0.05 ETH ≈ 100 USD
# 出价 0.05 ETH
cast send $AUCTION_PROXY_ADDRESS \
  "placeBid(uint256)" \
  0 \
  --value 0.05ether \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY_C

# 查询最高出价
cast call $AUCTION_PROXY_ADDRESS \
  "getHighestBid(uint256)(address,uint256,uint256,bool)" \
  0 \
  --rpc-url $SEPOLIA_RPC_URL
```

### 3.4 Account D 更高出价

Account D 出价 0.06 ETH：

```bash
cast send $AUCTION_PROXY_ADDRESS \
  "placeBid(uint256)" \
  0 \
  --value 0.06ether \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY_D

# Account C 的出价被自动记录为待提取
```

### 3.5 等待拍卖结束

```bash
# 方法 1: 等待直到 endTime 过去
sleep 3600  # 等待 1 小时

# 方法 2: 使用 Foundry 跳过时间（仅本地测试网）
cast warp $(($(date +%s) + 3600)) --rpc-url http://localhost:8545

# 查询当前时间
cast block timestamp --rpc-url $SEPOLIA_RPC_URL
```

### 3.6 结束拍卖

```bash
# 任何人都可以调用结束拍卖
cast send $AUCTION_PROXY_ADDRESS \
  "endAuction(uint256)" \
  0 \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY

# 验证 NFT 已转移给 Account D（最高出价者）
cast call $NFT_CONTRACT_ADDRESS \
  "ownerOf(uint256)(address)" \
  1 \
  --rpc-url $SEPOLIA_RPC_URL
# 应返回 Account D 的地址

# 查询 Account B（卖家）余额是否增加
cast balance $ACCOUNT_B --rpc-url $SEPOLIA_RPC_URL

# 查询手续费接收者余额
cast balance $FEE_RECIPIENT --rpc-url $SEPOLIA_RPC_URL
```

### 3.7 提取被超出的出价

Account C 提取之前被超出的出价：

```bash
# 查询待提取金额（合约内部状态，无法直接查询）
# 直接调用提款函数
cast send $AUCTION_PROXY_ADDRESS \
  "withdrawETH()" \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY_C

# 验证余额
cast balance $ACCOUNT_C --rpc-url $SEPOLIA_RPC_URL
```

---

## ERC20 代币拍卖测试

### 4.1 部署测试 ERC20 代币

创建测试脚本 `script/DeployMockToken.s.sol`：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockToken is ERC20 {
    constructor() ERC20("Mock USD", "MUSD") {
        _mint(msg.sender, 1000000 * 10**18);
    }
}

contract DeployMockToken is Script {
    function run() external {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        vm.startBroadcast(deployerPrivateKey);

        MockToken token = new MockToken();
        console.log("MockToken deployed at:", address(token));

        vm.stopBroadcast();
    }
}
```

部署测试代币：

```bash
forge script script/DeployMockToken.s.sol \
  --rpc-url $SEPOLIA_RPC_URL \
  --broadcast
```

### 4.2 配置 ERC20 价格预言机

```bash
# 使用 USDC/USD 价格预言机作为示例
USDC_PRICE_FEED=0xA2F78ab2355Fe2Cd48370b735A90A59a274934F8

# Owner 设置代币价格预言机
cast send $AUCTION_PROXY_ADDRESS \
  "setTokenPriceFeed(address,address)" \
  <MOCK_TOKEN_ADDRESS> \
  $USDC_PRICE_FEED \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY
```

### 4.3 分发测试代币

```bash
# Account A 向买家分发代币
cast send $MOCK_TOKEN_ADDRESS \
  "transfer(address,uint256)" \
  $ACCOUNT_C \
  10000ether \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY

cast send $MOCK_TOKEN_ADDRESS \
  "transfer(address,uint256)" \
  $ACCOUNT_D \
  10000ether \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY
```

### 4.4 创建 ERC20 拍卖

```bash
# Account B 创建接受 ERC20 的拍卖
cast send $AUCTION_PROXY_ADDRESS \
  "createAuction(address,uint256,uint256,uint256,address)" \
  $NFT_CONTRACT_ADDRESS \
  2 \
  3600 \
  100000000000000000000 \
  $MOCK_TOKEN_ADDRESS \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY_B
```

### 4.5 使用 ERC20 出价

```bash
# Account C 先授权拍卖合约
cast send $MOCK_TOKEN_ADDRESS \
  "approve(address,uint256)" \
  $AUCTION_PROXY_ADDRESS \
  1000000000000000000000 \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY_C

# 出价 500 MUSD
cast send $AUCTION_PROXY_ADDRESS \
  "placeBidWithToken(uint256,uint256)" \
  1 \
  500ether \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY_C
```

---

## 合约升级测试

### 5.1 准备升级

```bash
# 检查当前版本
cast call $AUCTION_PROXY_ADDRESS \
  "implementation()(address)" \
  --rpc-url $SEPOLIA_RPC_URL

# 查询当前手续费率
cast call $AUCTION_PROXY_ADDRESS \
  "feeRate()(uint256)" \
  --rpc-url $SEPOLIA_RPC_URL
```

### 5.2 执行升级到 V2

```bash
# 部署 AuctionV2 实现合约
forge script script/upgrade/Upgrade.s.sol \
  --rpc-url $SEPOLIA_RPC_URL \
  --broadcast \
  --verify \
  --etherscan-api-key $ETHERSCAN_API_KEY
```

### 5.3 验证升级

```bash
# 验证实现合约地址已更改
cast call $AUCTION_PROXY_ADDRESS \
  "implementation()(address)" \
  --rpc-url $SEPOLIA_RPC_URL

# 调用 V2 特有函数
cast call $AUCTION_PROXY_ADDRESS \
  "getFeeTierCount()(uint256)" \
  --rpc-url $SEPOLIA_RPC_URL

# 查询动态手续费层级
cast call $AUCTION_PROXY_ADDRESS \
  "getFeeTier(uint256)(uint256,uint256)" \
  0 \
  --rpc-url $SEPOLIA_RPC_URL
```

### 5.4 设置动态手续费层级

```bash
# 设置手续费层级：
# 层级 1: < 1000 USD -> 3%
# 层级 2: 1000-10000 USD -> 2.5%
# 层级 3: > 10000 USD -> 2%

cast send $AUCTION_PROXY_ADDRESS \
  "setFeeTier(uint256,uint256,uint256)" \
  0 \
  1000000000000000000000 \
  300 \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY

cast send $AUCTION_PROXY_ADDRESS \
  "setFeeTier(uint256,uint256,uint256)" \
  1 \
  10000000000000000000000 \
  250 \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY

cast send $AUCTION_PROXY_ADDRESS \
  "setFeeTier(uint256,uint256,uint256)" \
  2 \
  115792089237316195423570985008687907853269984665640564039457584007913129639935 \
  200 \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY
```

### 5.5 测试动态手续费

创建不同金额的拍卖，验证手续费计算：

```bash
# 创建小金额拍卖（应使用 3% 费率）
# ... 出价 500 USD
# 结束拍卖，验证手续费 = 500 * 0.03 = 15 USD

# 创建中等金额拍卖（应使用 2.5% 费率）
# ... 出价 5000 USD
# 结束拍卖，验证手续费 = 5000 * 0.025 = 125 USD

# 创建大金额拍卖（应使用 2% 费率）
# ... 出价 20000 USD
# 结束拍卖，验证手续费 = 20000 * 0.02 = 400 USD
```

---

## 综合场景测试

### 6.1 场景 1: 完整拍卖流程

```
1. Account A 铸造 NFT 给 Account B
2. Account B 创建拍卖（1 小时，最低 100 USD，接受 ETH）
3. Account C 出价 0.05 ETH
4. Account D 出价 0.06 ETH
5. 等待拍卖结束
6. 任何人调用 endAuction
7. 验证：
   - NFT 转移给 Account D
   - Account B 收到 0.06 ETH - 手续费
   - 手续费接收者收到手续费
   - Account C 可提取 0.05 ETH
```

### 6.2 场景 2: 取消拍卖

```
1. Account B 创建拍卖
2. 没有任何人出价
3. Account B 取消拍卖
4. 验证 NFT 返回给 Account B
```

### 6.3 场景 3: 无出价拍卖

```
1. Account B 创建拍卖
2. 拍卖时间结束，无人出价
3. 任何人调用 endAuction
4. 验证 NFT 返回给 Account B
```

### 6.4 场景 4: 多次竞价

```
1. Account B 创建拍卖
2. Account C 出价 0.05 ETH
3. Account D 出价 0.06 ETH
4. Account C 再次出价 0.07 ETH
5. Account D 再次出价 0.08 ETH
6. 结束拍卖
7. 验证 Account D 获胜
8. 验证 Account C 可提取 0.07 ETH
```

### 6.5 场景 5: 合约升级期间拍卖

```
1. Account B 创建拍卖（V1）
2. Account C 出价
3. 升级合约到 V2
4. Account D 继续出价
5. 结束拍卖（使用 V2 的动态手续费）
6. 验证所有功能正常
```

---

## 使用 Etherscan 测试

### 7.1 通过 Etherscan UI 测试

1. 访问合约地址：https://sepolia.etherscan.io/address/`<AUCTION_PROXY_ADDRESS>`

2. 切换到 "Contract" -> "Write Contract" 标签

3. 连接钱包（MetaMask）

4. 测试各个函数：
   - `createAuction`: 创建拍卖
   - `placeBid`: 出价（需要发送 ETH）
   - `endAuction`: 结束拍卖
   - `getAuction`: 查询拍卖信息
   - `getHighestBid`: 查询最高出价

### 7.2 读取合约状态

在 "Read Contract" 标签下：

```
- feeRate: 查询当前手续费率
- feeRecipient: 查询手续费接收者
- ethPriceFeed: 查询 ETH 价格预言机
```

---

## 测试报告模板

### 测试报告

**项目名称**: NFT 拍卖市场
**测试网络**: Sepolia 测试网
**测试日期**: 2024-XX-XX

#### 合约地址

| 合约类型 | 地址 | 交易哈希 |
|---------|------|---------|
| NFTMarketplace | 0x... | 0x... |
| Auction Proxy (V1) | 0x... | 0x... |
| Auction Implementation (V1) | 0x... | 0x... |
| Auction Implementation (V2) | 0x... | 0x... |

#### 测试用例执行情况

| 测试用例 | 状态 | 备注 |
|---------|------|-----|
| NFT 铸造 | ✅ 通过 | 铸造 5 个 NFT |
| NFT 转移 | ✅ 通过 | 正常转移 |
| NFT 查询 | ✅ 通过 | 元数据正确 |
| 创建 ETH 拍卖 | ✅ 通过 | 拍卖 ID 0 |
| ETH 出价 | ✅ 通过 | Account C 出价 0.05 ETH |
| 更高出价 | ✅ 通过 | Account D 出价 0.06 ETH |
| 结束拍卖 | ✅ 通过 | Account D 获得 NFT |
| 提取出价 | ✅ 通过 | Account C 提取 0.05 ETH |
| 创建 ERC20 拍卖 | ✅ 通过 | 使用 MockToken |
| ERC20 出价 | ✅ 通过 | Account C 出价 500 MUSD |
| 取消拍卖 | ✅ 通过 | 无出价时成功取消 |
| 无出价结束 | ✅ 通过 | NFT 返回卖家 |
| 合约升级 | ✅ 通过 | V1 -> V2 |
| 动态手续费 | ✅ 通过 | 三个层级正常 |
| 综合场景 | ✅ 通过 | 所有场景测试通过 |

#### Gas 使用情况

| 操作 | Gas Used | USD Cost (估算) |
|-----|----------|----------------|
| NFT 铸造 | ~50,000 | ~$0.10 |
| 创建拍卖 | ~150,000 | ~$0.30 |
| ETH 出价 | ~80,000 | ~$0.16 |
| 结束拍卖 | ~120,000 | ~$0.24 |
| 合约升级 | ~200,000 | ~$0.40 |

#### 发现的问题

| 问题描述 | 严重性 | 状态 |
|---------|--------|------|
| 无 | - | - |

#### 测试结论

✅ 所有测试用例通过，合约功能正常，可以部署到主网。

#### 测试人员签名

测试人员: ______________
日期: ______________

---

## 测试检查清单

- [ ] NFT 铸造功能正常
- [ ] NFT 转移功能正常
- [ ] NFT 元数据查询正常
- [ ] 创建 ETH 拍卖成功
- [ ] 创建 ERC20 拍卖成功
- [ ] ETH 出价功能正常
- [ ] ERC20 出价功能正常
- [ ] 出价验证正常（最低出价、高出价）
- [ ] 结束拍卖功能正常
- [ ] NFT 转移给最高出价者
- [ ] 资金转移给卖家（扣除手续费）
- [ ] 手续费计算正确
- [ ] 手续费转移给接收者
- [ ] 取消拍卖功能正常
- [ ] 无出价时结束拍卖正常
- [ ] 提取被超出出价功能正常
- [ ] 合约升级功能正常
- [ ] 升级后数据保留正常
- [ ] 动态手续费计算正确
- [ ] Chainlink 价格查询正常
- [ ] 所有事件日志正常触发
- [ ] Etherscan 验证通过
- [ ] 综合场景测试通过

---

## 常用 Cast 命令参考

```bash
# 发送交易
cast send <CONTRACT> "<SIGNATURE>(<TYPES>)" <ARGS> --rpc-url <RPC> --private-key <KEY>

# 调用只读函数
cast call <CONTRACT> "<SIGNATURE>(<TYPES>)" <ARGS> --rpc-url <RPC>

# 查询余额
cast balance <ADDRESS> --rpc-url <RPC>

# 查询区块信息
cast block timestamp --rpc-url <RPC>
cast block number --rpc-url <RPC>

# 解码交易收据
cast receipt <TX_HASH> --rpc-url <RPC>

# 发送 ETH
cast send <ADDRESS> --value <AMOUNT> --rpc-url <RPC> --private-key <KEY>
```

测试完成后，请将测试结果记录到测试报告模板中。
